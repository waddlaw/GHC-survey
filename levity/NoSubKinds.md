- [NoSubKinds](https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds)

このページは、`Simon PJ` のアイデアをもとに、 `GHC` の部分カインド付け (sub-kinding) を取り除くための設計に関する計画の記録である。 `Richard E.` はボランティアで実装を手伝った。

注意: このページの事柄は既に実装済みである。実際に何が起きたのか、ページの上から下に時系列順となっている。

# The current story

今現在、様々な**基本**カインド ("base" kinds) が存在する。

- `*`: lifted boxed types のカインド。これは、`*` カインドを持つ型がボトム (bottom) を含み、ポインタによって表現される。
- `#`: unlifted types のカインド。このカインドを持つ型はボトムにはなれない。`Int#` や `Double#` などの、多くの unlifted type は unboxed であるが、 `Array#` のように boxed (ヒープポインタで表現される) な場合もある。
- `Constraint`: Haskell の型クラス制約のカインド。厄介なことに、
  - `*` と `Constraint` の型チェックは完全に異なるカインドでなければならない。そのため、型シグネチャ `f :: Int => Int` はリジェクトされる。
  - GHC内部において重要な点として、 `Constraint` と `*` は区別の付かないものとして処理する。**SLPJ** なぜ?以前は `GND` が辞書の役割となっていたため、そのように利用していたが、それ以上のことは何もしていない。**RAE** 我々は1メンバクラスを強制的に変換する時にこのトリックをまだ使っている。正しいよね？さらに、`*` と `Constraint` が異なっていれば、複数の異なるアローを必要とするだろう。どんな場合でも、この問題と今回の提案は完全に関係の無いものだ。

  そのため、`tcEqType` は `Constraint` と `*` を区別 (Haskell の中での区別) するが、 `eqType` は両者を等しいものとして扱う。

- `OpenKind`: `*` と `#` のスーパーカインド。`OpenKind` は様々な理由で存在している。
  - `(->)` にカインドを与え、`OpenKind -> OpenKind -> *` として使うため。**SLPJ** 違う。我々は `(->)` に対して実際に `* -> * -> *` を与えている。ただ、 `(->)` は部分適用しないという特別なカインド規則がある。**RAE** はい。しかし、以下の立場に立ってみたら違うのでは？
  - `error :: forall (a :: OpenKind). String -> a` と `undefined :: forall (a :: OpenKind). a)` に型を与えるためである。`error Int# "foo" :: Int"` という形を許容したい。
  - 推論において、ラムダに束縛された変数にカインドを与える。例: `\x -> 3# +# x` 。ラムダ式が出現した時、アルファの型を与え、ユニフィケーション変数とする。しかし、アルファ型のカインドは何にすれば良いのだろうか？`*` では無いため、ラムダ式はリジェクトされてしまう。そのため、ここで `OpenKind` を与える。
  - `BOX`: カインドの分類。すなわち、 `* :: BOX`, `# :: BOX` であり、ややこしいことに `BOX :: BOX` である。

`OpenKind` の全体的な動作は満足いくものではない。例として、このような抽象化はできない。

```haskell
myError s = error ("Blah" ++ s)
```

今の所、`myError` は `Int#` 型では利用できない。

